# Event Loops and Highly Scalable Asynchronous Programming

## Introduction

In the [previous article](https://hackmd.io/fQRXo1VsRcaFdvoMx7aBIw), I described event loops and asynchrnouns programming. In this article, I will describe the application I wrote the uses the asynchronous programming to register and handle events. These events could be generated by either the system or the user. The examples or such events are timers, network call, network interface change, file content change, registry change (windows), getting notification when configuration changes etc.

I have used [boost](https://www.boost.org/) C++ framework for the implementation. There are other frameworks available for C/C++ as well. Most notably [libEvent](https://libevent.org/) and [ACE](https://github.com/psigen/ace). All these frameworks abstract out the operating system level implementations of `ePoll, kQueue or IOCP` and provide a uniform interface. Boost uses ASIO for this purpose. Boost is also a very rich library that has many additional utilties that are now getting incorporated in standard C++ library (including asio starting from C++ 17)

## Application
Windows messaging system was very efficient. It could handle a very large number of messages coming in very fast such as `MOUSE_MOVE`. The interface was standard `OnMessage(WPARAM, LPARAM)` format. You would get to `PostMessage` or `SendMessage` with these two parameters. You could essentially send any pointer or a number as a part of the message. The PostMessage would queue the message. The messages would get serviced by the main Event Loop in the order they arrive. `PostMessage` would return right away and it was the responsibility of the receiver to free the memory. With C++ smart pointers, that burden is gone. Of course, smart pointers bring their own set of issues such as circular dependencies. `SendMessage` on the other hand would block until the message was served. The whole thing would run in a single thread. If you had something that required a good amount of processing, you had to spawn of a new thread. Otherwise, the UI would freeze.


![](https://i.imgur.com/s0pxEsD.png)


The framework in this application, mirrors this Windows framework. You could add your `message` with an ID and you define its handler. 

```
// Ids for the messages
enum
{
  cInitialize,
  cCleanUp,
};


// Mapping to invoke the function based on the ID
BEGIN_LIBMSG_MAP(TestMsgThread, LibMsgThread)
  ON_MESSAGE(cInitialize, TestMsgThread::OnInitialize)
  ON_MESSAGE(cCleanUp, TestMsgThread::OnCleanUp)
END_LIBMSG_MAP()


// Actual function implementations
void TestMsgThread::OnInitialize(LM_WPARAM wParam, LM_LPARAM lParam) {
  std::cout << "==>OnInitialize" << endl;
}

void TestMsgThread::OnCleanUp(LM_WPARAM wParam, LM_LPARAM lParam) {
  std::cout << "==>OnCleanUp\n" << endl;
}

```

All functions follow the same signature. That is what allows us to do the BEGIN_LIBMSG_MAP trick. I could have easily extended this to handle more parameters. The trick is done using `boost::bind` and `boost::post`. You are welcome to explore the source code and post any questions.

The output from the program
```
Welcome to the world of Asynchronous Programming!!
==>LibMsgThread::Start
Thread id = 0x700003ae4000
==>OnInitialize. Time = 1641858231
==>OnDoSomethingTask. Time = 1641858236 - Task Fired to do something
==>OnDoSomethingTask. Time = 1641858241 - Task Fired to do something
==>OnDoSomethingTask. Time = 1641858246 - Task Fired to do something
==>OnDoSomethingTask. Time = 1641858251 - Task Fired to do something
```

So far I only have user posted messages and Timers. However, it is not limited to user messages. You can easily add system events (such as file change, network events such as new socket, interface changed etc). The great thing is that all you need is to register either a file descritor (for Linux, Mac, iOS and Android) or HANDLE for Windows and then you add the handle to our Event Loop and Viola, you have a complete high performing single threaded asynchrnous event loop.








