# Event Loops and Highly Scalable Asynchronous Programming

## Introduction

In the [previous article](https://hackmd.io/fQRXo1VsRcaFdvoMx7aBIw), I described event loops and asynchronous programming. In this article, I will describe the application I wrote the uses the asynchronous programming to register and handle events. These events could be generated by either the system or the user. The examples or such events are timers, network call, network interface change, file content change, registry change (windows), getting notification when configuration changes etc.

I have used [boost](https://www.boost.org/) C++ framework for the implementation. There are other frameworks available for C/C++ as well. Most notably [libEvent](https://libevent.org/) and [ACE](https://github.com/psigen/ace). All these frameworks abstract out the operating system level implementations of `ePoll, kQueue or IOCP` and provide a uniform interface. Boost uses ASIO for this purpose. Boost is also a very rich library that has many additional utilties that are now getting incorporated in standard C++ library (including asio starting from C++ 17)

## Application
Windows messaging system was very efficient. It could handle a very large number of messages coming in very fast such as `MOUSE_MOVE`. The interface was standard `OnMessage(WPARAM, LPARAM)` format. You would get to `PostMessage` or `SendMessage` with these two parameters. You could essentially send any pointer or a number as a part of the message. The PostMessage would queue the message. The messages would get serviced by the main Event Loop in the order they arrive. `PostMessage` would return right away and it was the responsibility of the receiver to free the memory. With C++ smart pointers, that burden is gone. Of course, smart pointers bring their own set of issues such as circular dependencies. `SendMessage` on the other hand would block until the message was served. The whole thing would run in a single thread. If you had something that required a good amount of processing, you had to spawn of a new thread. Otherwise, the UI would freeze.

![](https://i.imgur.com/s0pxEsD.png)

The framework in this application, mirrors this Windows framework. You just add your `message` with an ID and you define its handler. The application successfully runs on both Windows and Mac. Most of the interface is abstracted out. That way you can focus on the core logic of the application. If you don't like the callback format, the great thing is that you can define your own. You can pass the typed data for example instead of WPARAM and LPARAM

The application demonstrates multiple different kinds of events
- User Message - You can post your message (Here Initialize message)
- Timers - You can create various kinds of timers. Periodic, One Time Timer. You can cancel the timer etc.
- Network Change - You can get an event whenever the network changes. 
- Registry Change - This of course applies only to Windows. You can use it to monitor Windows Application start location for the registry. That way if a malware modifies the entry, you will get a notification right away and take action

The great thing is that all you need is to register either a file descritor (for Linux, Mac, iOS and Android) or HANDLE for Windows. You then add a callback or handler message along with MessageID to our Message Thread and Viola, you have a complete high performing single threaded asynchrnous event loop. I have not tried it but this application should run on iOS, Linux and Android as well. It currently works on Windows and Mac.



```
// Ids for the messages
enum
{
  cInitialize,
  cCleanUp,
  cDoSomethingTask,
  cNetworkChanged,
};


// Mapping to invoke the function based on the ID
BEGIN_LIBMSG_MAP(TestMsgThread, LibMsgThread)
  ON_MESSAGE(cInitialize, TestMsgThread::OnInitialize)
  ON_MESSAGE(cCleanUp, TestMsgThread::OnCleanUp)
  ON_MESSAGE(cDoSomethingTask, TestMsgThread::OnDoSomethingTask)
  ON_MESSAGE(cNetworkChanged, TestMsgThread::OnNetworkChanged)
END_LIBMSG_MAP()


// Actual function implementations
void TestMsgThread::OnInitialize(LM_WPARAM wParam, LM_LPARAM lParam) {
  std::cout << "==>OnInitialize" << endl;
}

void TestMsgThread::OnCleanUp(LM_WPARAM wParam, LM_LPARAM lParam) {
  std::cout << "==>OnCleanUp\n" << endl;
}

void TestMsgThread::OnDoSomethingTask(LM_WPARAM wParam, LM_LPARAM lParam) {
  std::cout << "==>OnDoSomethingTask. Time = " << time(nullptr) << " - Task Fired to do something" << endl;
}

void TestMsgThread::OnNetworkChanged(LM_WPARAM wParam, LM_LPARAM lParam) {
  std::cout << "==>OnNetworkChanged." << endl;
}
```

All functions follow the same signature. That is what allows us to do the BEGIN_LIBMSG_MAP trick. I could have easily extended this to handle more parameters. The trick is done using `boost::bind` and `boost::post`. You are welcome to explore the source code and post any questions.

The output from the program
```
Welcome to the world of Asynchronous Programming!!
==>LibMsgThread::Start
Thread id = 0x70000e0bb000
==>OnInitialize. Time = 1642568940
==>OnDoSomethingTask. Time = 1642568945 - Task Fired to do something
==>OnDoSomethingTask. Time = 1642568950 - Task Fired to do something
==>OnNetworkChanged.
==>OnDoSomethingTask. Time = 1642568955 - Task Fired to do something
==>OnDoSomethingTask. Time = 1642568960 - Task Fired to do something
```

